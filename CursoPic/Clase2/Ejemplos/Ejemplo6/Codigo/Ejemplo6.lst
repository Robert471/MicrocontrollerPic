CCS PCM C Compiler, Version 4.057, 59222               03-Dic.-16 06:58

               Filename: D:\LaboTEC\Cursos\Curso_PIC\Modulo_1\Clase2\Ejemplos\Ejemplo6\Codigo\Ejemplo6.lst

               ROM used: 1446 words (18%)
                         Largest free fragment is 2048
               RAM used: 15 (4%) at main() level
                         53 (14%) worst case
               Stack:    4 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   55C
0003:  NOP
.................... #include "16f877a.h"                   // define el pic que vamos a utilizar 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #fuses XT                              // defino fusibles 
.................... #use delay(clock=4Mhz)                // frecuencia 20Mhz 
.................... #include <HDM64GS12.c>                 // Librerias para el  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           HDM64GS12.c                           //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. //// 
.................... //// The driver treats the upper left pixel as (0,0).                //// 
.................... ////                                                                 //// 
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM //// 
.................... //// to decrease the time it takes to update the display.            //// 
.................... //// glcd_update() must then be called to update the display after   //// 
.................... //// changing the pixel information.                                 //// 
.................... //// See ex_glcd.c for suggested usage.                              //// 
.................... //// See KS0108.c for controlling a single 64 by 64 display          //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0  - LCD operating voltage (Constrast adjustment)        //// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_update()                                                  //// 
.................... ////     * Write the display data stored in RAM to the LCD           //// 
.................... ////     * Only available if FAST_GLCD is defined                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef HDM64GS12 
.................... #define HDM64GS12 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH   128 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1     PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2     PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI      PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW      PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E       PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST     PIN_C0   // Reset 
.................... #endif 
....................  
.................... #define GLCD_LEFT    0 
.................... #define GLCD_RIGHT   1 
....................  
.................... #ifndef ON 
.................... #define ON           1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF          0 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void glcd_init(int1 mode); 
.................... void glcd_pixel(int8 x, int8 y, int1 color); 
.................... void glcd_fillScreen(int1 color); 
.................... void glcd_writeByte(int1 side, BYTE data); 
.................... BYTE glcd_readByte(int1 side); 
.................... void glcd_update(); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef FAST_GLCD 
.................... struct 
.................... { 
....................    int8 left[512]; 
....................    int8 right[512]; 
.................... } displayData; 
.................... #endif 
....................  
....................  
.................... // Purpose:       Initialize the LCD. 
.................... //                Call before using any other LCD function. 
.................... // Inputs:        OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
0239:  BCF    20.0
023A:  MOVF   20,W
023B:  BSF    03.5
023C:  MOVWF  07
023D:  BCF    03.5
023E:  BSF    07.0
*
0567:  MOVLW  FF
0568:  BCF    03.5
0569:  MOVWF  20
....................    output_low(GLCD_E); 
*
023F:  BSF    03.5
0240:  BCF    06.5
0241:  BCF    03.5
0242:  BCF    06.5
....................    output_low(GLCD_CS1); 
0243:  BSF    03.5
0244:  BCF    06.0
0245:  BCF    03.5
0246:  BCF    06.0
....................    output_low(GLCD_CS2); 
0247:  BSF    03.5
0248:  BCF    06.1
0249:  BCF    03.5
024A:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                 // Set for instruction 
024B:  BSF    03.5
024C:  BCF    06.2
024D:  BCF    03.5
024E:  BCF    06.2
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top 
024F:  CLRF   4D
0250:  MOVLW  C0
0251:  MOVWF  4E
0252:  CALL   1EA
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen 
0253:  MOVLW  01
0254:  MOVWF  4D
0255:  MOVLW  C0
0256:  MOVWF  4E
0257:  CALL   1EA
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0 
0258:  CLRF   4D
0259:  MOVLW  40
025A:  MOVWF  4E
025B:  CALL   1EA
....................    glcd_writeByte(GLCD_RIGHT, 0x40); 
025C:  MOVLW  01
025D:  MOVWF  4D
025E:  MOVLW  40
025F:  MOVWF  4E
0260:  CALL   1EA
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0 
0261:  CLRF   4D
0262:  MOVLW  B8
0263:  MOVWF  4E
0264:  CALL   1EA
....................    glcd_writeByte(GLCD_RIGHT, 0xB8); 
0265:  MOVLW  01
0266:  MOVWF  4D
0267:  MOVLW  B8
0268:  MOVWF  4E
0269:  CALL   1EA
....................  
....................    if(mode == ON) 
026A:  DECFSZ 29,W
026B:  GOTO   276
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on 
026C:  CLRF   4D
026D:  MOVLW  3F
026E:  MOVWF  4E
026F:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, 0x3F); 
0270:  MOVLW  01
0271:  MOVWF  4D
0272:  MOVLW  3F
0273:  MOVWF  4E
0274:  CALL   1EA
....................    } 
....................    else 
0275:  GOTO   27F
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off 
0276:  CLRF   4D
0277:  MOVLW  3E
0278:  MOVWF  4E
0279:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, 0x3E); 
027A:  MOVLW  01
027B:  MOVWF  4D
027C:  MOVLW  3E
027D:  MOVWF  4E
027E:  CALL   1EA
....................    } 
....................  
....................    glcd_fillScreen(OFF);                // Clear the display 
027F:  CLRF   2A
....................  
....................    #ifdef FAST_GLCD 
....................    glcd_update(); 
....................    #endif 
.................... } 
*
02C5:  BCF    0A.3
02C6:  BCF    0A.4
02C7:  GOTO   57C (RETURN)
....................  
....................  
.................... // Purpose:    Update the LCD with data from the display arrays 
.................... #ifdef FAST_GLCD 
.................... void glcd_update() 
.................... { 
....................    int8 i, j; 
....................    int8 *p1, *p2; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0 
....................       glcd_writeByte(GLCD_RIGHT, 0x40); 
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address 
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8); 
....................       output_high(GLCD_DI);                     // Set for data 
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
....................       { 
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off 
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Turn a pixel on a graphic LCD on or off 
.................... // Inputs:     1) x - the x coordinate of the pixel 
.................... //             2) y - the y coordinate of the pixel 
.................... //             3) color - ON or OFF 
.................... void glcd_pixel(int8 x, int8 y, int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    int8* p; 
....................    int16 temp; 
....................    temp =  y/8; 
....................    temp *= 64; 
....................    temp += x; 
....................  
....................    if(x > 63) 
....................    { 
....................       p = displayData.right + temp - 64; 
....................    } 
....................    else 
....................    { 
....................       p = displayData.left + temp; 
....................    } 
....................  
....................    if(color) 
....................    { 
....................       bit_set(*p, y%8); 
....................    } 
....................    else 
....................    { 
....................       bit_clear(*p, y%8); 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    BYTE data; 
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD 
*
02F6:  BCF    48.0
....................  
....................    if(x > 63)              // Check for first or second display area 
02F7:  MOVF   44,W
02F8:  SUBLW  3F
02F9:  BTFSC  03.0
02FA:  GOTO   2FE
....................    { 
....................       x -= 64; 
02FB:  MOVLW  40
02FC:  SUBWF  44,F
....................       side = GLCD_RIGHT; 
02FD:  BSF    48.0
....................    } 
....................  
....................    output_low(GLCD_DI);                         // Set for instruction 
02FE:  BSF    03.5
02FF:  BCF    06.2
0300:  BCF    03.5
0301:  BCF    06.2
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code 
0302:  BCF    44.7
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code 
0303:  BSF    44.6
....................    glcd_writeByte(side, x);                     // Set the horizontal address 
0304:  MOVLW  00
0305:  BTFSC  48.0
0306:  MOVLW  01
0307:  MOVWF  49
0308:  MOVWF  4D
0309:  MOVF   44,W
030A:  MOVWF  4E
030B:  CALL   1EA
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address 
030C:  MOVLW  00
030D:  BTFSC  48.0
030E:  MOVLW  01
030F:  MOVWF  49
0310:  RRF    45,W
0311:  MOVWF  77
0312:  RRF    77,F
0313:  RRF    77,F
0314:  MOVLW  1F
0315:  ANDWF  77,F
0316:  MOVF   77,W
0317:  ANDLW  BF
0318:  IORLW  B8
0319:  MOVWF  4C
031A:  MOVF   49,W
031B:  MOVWF  4D
031C:  MOVF   4C,W
031D:  MOVWF  4E
031E:  CALL   1EA
....................    output_high(GLCD_DI);                        // Set for data 
031F:  BSF    03.5
0320:  BCF    06.2
0321:  BCF    03.5
0322:  BSF    06.2
....................    glcd_readByte(side);                         // Need two reads to get data 
0323:  MOVLW  00
0324:  BTFSC  48.0
0325:  MOVLW  01
0326:  MOVWF  49
0327:  MOVWF  4A
0328:  CALL   2C8
....................    data = glcd_readByte(side);                  //  at new address 
0329:  MOVLW  00
032A:  BTFSC  48.0
032B:  MOVLW  01
032C:  MOVWF  49
032D:  MOVWF  4A
032E:  CALL   2C8
032F:  MOVF   78,W
0330:  MOVWF  47
....................  
....................    if(color == ON) 
0331:  DECFSZ 46,W
0332:  GOTO   343
....................       bit_set(data, y%8);        // Turn the pixel on 
0333:  MOVF   45,W
0334:  ANDLW  07
0335:  MOVWF  49
0336:  MOVLW  01
0337:  MOVWF  77
0338:  MOVF   49,W
0339:  MOVWF  78
033A:  BTFSC  03.2
033B:  GOTO   340
033C:  BCF    03.0
033D:  RLF    77,F
033E:  DECFSZ 78,F
033F:  GOTO   33C
0340:  MOVF   77,W
0341:  IORWF  47,F
....................    else                          // or 
0342:  GOTO   353
....................       bit_clear(data, y%8);      // turn the pixel off 
0343:  MOVF   45,W
0344:  ANDLW  07
0345:  MOVWF  49
0346:  MOVLW  01
0347:  MOVWF  77
0348:  MOVF   49,W
0349:  MOVWF  78
034A:  BTFSC  03.2
034B:  GOTO   350
034C:  BCF    03.0
034D:  RLF    77,F
034E:  DECFSZ 78,F
034F:  GOTO   34C
0350:  MOVF   77,W
0351:  XORLW  FF
0352:  ANDWF  47,F
....................  
....................    output_low(GLCD_DI);          // Set for instruction 
0353:  BSF    03.5
0354:  BCF    06.2
0355:  BCF    03.5
0356:  BCF    06.2
....................    glcd_writeByte(side, x);      // Set the horizontal address 
0357:  MOVLW  00
0358:  BTFSC  48.0
0359:  MOVLW  01
035A:  MOVWF  49
035B:  MOVWF  4D
035C:  MOVF   44,W
035D:  MOVWF  4E
035E:  CALL   1EA
....................    output_high(GLCD_DI);         // Set for data 
035F:  BSF    03.5
0360:  BCF    06.2
0361:  BCF    03.5
0362:  BSF    06.2
....................    glcd_writeByte(side, data);   // Write the pixel data 
0363:  MOVLW  00
0364:  BTFSC  48.0
0365:  MOVLW  01
0366:  MOVWF  49
0367:  MOVWF  4D
0368:  MOVF   47,W
0369:  MOVWF  4E
036A:  CALL   1EA
.................... } 
036B:  RETLW  00
.................... #endif 
....................  
....................  
.................... // Purpose:    Fill the LCD screen with the passed in color 
.................... // Inputs:     ON  - turn all the pixels on 
.................... //             OFF - turn all the pixels off 
.................... void glcd_fillScreen(int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    int8  data; 
....................    int8  *p1, *p2; 
....................    int16 i; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................    data = 0xFF * color; 
....................  
....................    for(i=0; i<512; ++i) 
....................    { 
....................    	*p1++ = data; 
....................    	*p2++ = data; 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    int8 i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
0280:  CLRF   2B
0281:  MOVF   2B,W
0282:  SUBLW  07
0283:  BTFSS  03.0
0284:  GOTO   2C5
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
0285:  BSF    03.5
0286:  BCF    06.2
0287:  BCF    03.5
0288:  BCF    06.2
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0 
0289:  CLRF   4D
028A:  MOVLW  40
028B:  MOVWF  4E
028C:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000); 
028D:  MOVLW  01
028E:  MOVWF  4D
028F:  MOVLW  40
0290:  MOVWF  4E
0291:  CALL   1EA
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address 
0292:  MOVF   2B,W
0293:  IORLW  B8
0294:  MOVWF  2D
0295:  CLRF   4D
0296:  MOVF   2D,W
0297:  MOVWF  4E
0298:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000); 
0299:  MOVF   2B,W
029A:  IORLW  B8
029B:  MOVWF  2D
029C:  MOVLW  01
029D:  MOVWF  4D
029E:  MOVF   2D,W
029F:  MOVWF  4E
02A0:  CALL   1EA
....................       output_high(GLCD_DI);                     // Set for data 
02A1:  BSF    03.5
02A2:  BCF    06.2
02A3:  BCF    03.5
02A4:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
02A5:  CLRF   2C
02A6:  MOVF   2C,W
02A7:  SUBLW  3F
02A8:  BTFSS  03.0
02A9:  GOTO   2C3
....................       { 
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off 
02AA:  MOVLW  FF
02AB:  MOVWF  3B
02AC:  MOVF   2A,W
02AD:  MOVWF  3C
02AE:  CALL   214
02AF:  MOVF   78,W
02B0:  MOVWF  2D
02B1:  CLRF   4D
02B2:  MOVF   78,W
02B3:  MOVWF  4E
02B4:  CALL   1EA
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off 
02B5:  MOVLW  FF
02B6:  MOVWF  3B
02B7:  MOVF   2A,W
02B8:  MOVWF  3C
02B9:  CALL   214
02BA:  MOVF   78,W
02BB:  MOVWF  2D
02BC:  MOVLW  01
02BD:  MOVWF  4D
02BE:  MOVF   78,W
02BF:  MOVWF  4E
02C0:  CALL   1EA
....................       } 
02C1:  INCF   2C,F
02C2:  GOTO   2A6
....................    } 
02C3:  INCF   2B,F
02C4:  GOTO   281
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Write a byte of data to the specified chip 
.................... // Inputs:     1) chipSelect - which chip to write the data to 
.................... //             2) data - the byte of data to write 
.................... void glcd_writeByte(int1 side, BYTE data) 
.................... { 
....................    if(side)                   // Choose which side to write to 
*
01EA:  MOVF   4D,F
01EB:  BTFSC  03.2
01EC:  GOTO   1F2
....................       output_high(GLCD_CS2); 
01ED:  BSF    03.5
01EE:  BCF    06.1
01EF:  BCF    03.5
01F0:  BSF    06.1
....................    else 
01F1:  GOTO   1F6
....................       output_high(GLCD_CS1); 
01F2:  BSF    03.5
01F3:  BCF    06.0
01F4:  BCF    03.5
01F5:  BSF    06.0
....................  
....................    output_low(GLCD_RW);       // Set for writing 
01F6:  BSF    03.5
01F7:  BCF    06.4
01F8:  BCF    03.5
01F9:  BCF    06.4
....................    output_d(data);            // Put the data on the port 
01FA:  BSF    03.5
01FB:  CLRF   08
01FC:  BCF    03.5
01FD:  MOVF   4E,W
01FE:  MOVWF  08
....................    delay_cycles(1); 
01FF:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
0200:  BSF    03.5
0201:  BCF    06.5
0202:  BCF    03.5
0203:  BSF    06.5
....................    delay_cycles(5); 
0204:  GOTO   205
0205:  GOTO   206
0206:  NOP
....................    output_low(GLCD_E); 
0207:  BSF    03.5
0208:  BCF    06.5
0209:  BCF    03.5
020A:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
020B:  BSF    03.5
020C:  BCF    06.0
020D:  BCF    03.5
020E:  BCF    06.0
....................    output_low(GLCD_CS2); 
020F:  BSF    03.5
0210:  BCF    06.1
0211:  BCF    03.5
0212:  BCF    06.1
.................... } 
0213:  RETLW  00
....................  
....................  
.................... // Purpose:    Reads a byte of data from the specified chip 
.................... // Ouputs:     A byte of data read from the chip 
.................... BYTE glcd_readByte(int1 side) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................  
....................    set_tris_d(0xFF);          // Set port d to input 
*
02C8:  MOVLW  FF
02C9:  BSF    03.5
02CA:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
02CB:  BCF    06.4
02CC:  BCF    03.5
02CD:  BSF    06.4
....................  
....................    if(side)                   // Choose which side to write to 
02CE:  MOVF   4A,F
02CF:  BTFSC  03.2
02D0:  GOTO   2D6
....................       output_high(GLCD_CS2); 
02D1:  BSF    03.5
02D2:  BCF    06.1
02D3:  BCF    03.5
02D4:  BSF    06.1
....................    else 
02D5:  GOTO   2DA
....................       output_high(GLCD_CS1); 
02D6:  BSF    03.5
02D7:  BCF    06.0
02D8:  BCF    03.5
02D9:  BSF    06.0
....................  
....................    delay_cycles(1); 
02DA:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
02DB:  BSF    03.5
02DC:  BCF    06.5
02DD:  BCF    03.5
02DE:  BSF    06.5
....................    delay_cycles(4); 
02DF:  GOTO   2E0
02E0:  GOTO   2E1
....................    data = input_d();          // Get the data from the display's output register 
02E1:  MOVLW  FF
02E2:  BSF    03.5
02E3:  MOVWF  08
02E4:  BCF    03.5
02E5:  MOVF   08,W
02E6:  MOVWF  4B
....................    output_low(GLCD_E); 
02E7:  BSF    03.5
02E8:  BCF    06.5
02E9:  BCF    03.5
02EA:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
02EB:  BSF    03.5
02EC:  BCF    06.0
02ED:  BCF    03.5
02EE:  BCF    06.0
....................    output_low(GLCD_CS2); 
02EF:  BSF    03.5
02F0:  BCF    06.1
02F1:  BCF    03.5
02F2:  BCF    06.1
....................    return data;               // Return the read data 
02F3:  MOVF   4B,W
02F4:  MOVWF  78
.................... } 
02F5:  RETLW  00
....................  
.................... #endif 
....................  
.................... #include <graphics.c>                  // manejo de la GLCD 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          graphics.c                             //// 
.................... ////                                                                 //// 
.................... ////   This file contains functions to draw lines, rectangles, bars, //// 
.................... ////   circles and text to a display. A function which draws a       //// 
.................... ////   single pixel must be defined before calling the functions in  //// 
.................... ////   this file. Call it glcd_pixel(x, y, color) where x is the     //// 
.................... ////   horizontal coordinate, y is the vertical coordinate, and      //// 
.................... ////   color is 1 bit to turn the pixel on or off.                   //// 
.................... ////                                                                 //// 
.................... ////   * Note: (0, 0) is treated as the upper left corner            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1, y1, x2, y2, color)                               //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color                                      //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1, y1, x2, y2, fill, color)                         //// 
.................... ////     * Draws a rectangle with one corner at point (x1,y1) and    //// 
.................... ////       the other corner at point (x2,y2)                         //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1, y1, x2, y2, width, color)                         //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point                                              //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x, y, radius, fill, color)                         //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x, y, textptr, size, color)                        //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y) //// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall            //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - This function wraps characters to the next line    //// 
.................... ////              use #define GLCD_WIDTH to specify a display width  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef GRAPHICS_DRAWING_FUNCTIONS 
.................... #define GRAPHICS_DRAWING_FUNCTIONS 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef ON 
.................... #define ON  1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF 0 
.................... #endif 
....................  
.................... #ifndef YES 
.................... #define YES 1 
.................... #endif 
....................  
.................... #ifndef NO 
.................... #define NO  0 
.................... #endif 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Defines a 5x7 font 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... const int8 FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const int8 FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_line(int16 x1, int16 y1, int16 x2, int16 y2, int1 color) 
.................... #else 
.................... void glcd_line(int8 x1, int8 y1, int8 x2, int8 y2, int1 color) 
.................... #endif 
.................... { 
....................    int16        dy, dx; 
....................    signed int8  addx=1, addy=1; 
*
036C:  MOVLW  01
036D:  MOVWF  3D
036E:  MOVWF  3E
....................    signed int16 P, diff; 
....................  
....................    #ifdef LARGE_LCD 
....................    int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    int8 i=0; 
036F:  CLRF   43
....................    dx = abs((signed int8)(x2 - x1)); 
0370:  MOVF   34,W
0371:  SUBWF  36,W
0372:  MOVWF  44
0373:  MOVF   44,W
0374:  BTFSS  44.7
0375:  GOTO   378
0376:  MOVF   44,W
0377:  SUBLW  00
0378:  CLRF   7A
0379:  MOVWF  3B
037A:  MOVF   7A,W
037B:  MOVWF  3C
....................    dy = abs((signed int8)(y2 - y1)); 
037C:  MOVF   35,W
037D:  SUBWF  37,W
037E:  MOVWF  44
037F:  MOVF   44,W
0380:  BTFSS  44.7
0381:  GOTO   384
0382:  MOVF   44,W
0383:  SUBLW  00
0384:  CLRF   7A
0385:  MOVWF  39
0386:  MOVF   7A,W
0387:  MOVWF  3A
....................    #endif 
....................  
....................    if(x1 > x2) 
0388:  MOVF   34,W
0389:  SUBWF  36,W
038A:  BTFSC  03.0
038B:  GOTO   38E
....................       addx = -1; 
038C:  MOVLW  FF
038D:  MOVWF  3D
....................    if(y1 > y2) 
038E:  MOVF   35,W
038F:  SUBWF  37,W
0390:  BTFSC  03.0
0391:  GOTO   394
....................       addy = -1; 
0392:  MOVLW  FF
0393:  MOVWF  3E
....................  
....................    if(dx >= dy) 
0394:  MOVF   3A,W
0395:  SUBWF  3C,W
0396:  BTFSS  03.0
0397:  GOTO   3E0
0398:  BTFSS  03.2
0399:  GOTO   39E
039A:  MOVF   39,W
039B:  SUBWF  3B,W
039C:  BTFSS  03.0
039D:  GOTO   3E0
....................    { 
....................       dy *= 2; 
039E:  BCF    03.0
039F:  RLF    39,F
03A0:  RLF    3A,F
....................       P = dy - dx; 
03A1:  MOVF   3B,W
03A2:  SUBWF  39,W
03A3:  MOVWF  77
03A4:  MOVF   3A,W
03A5:  MOVWF  7A
03A6:  MOVF   3C,W
03A7:  BTFSS  03.0
03A8:  INCFSZ 3C,W
03A9:  SUBWF  7A,F
03AA:  MOVF   77,W
03AB:  MOVWF  3F
03AC:  MOVF   7A,W
03AD:  MOVWF  40
....................       diff = P - dx; 
03AE:  MOVF   3B,W
03AF:  SUBWF  3F,W
03B0:  MOVWF  41
03B1:  MOVF   40,W
03B2:  MOVWF  42
03B3:  MOVF   3C,W
03B4:  BTFSS  03.0
03B5:  INCFSZ 3C,W
03B6:  SUBWF  42,F
....................  
....................       for(; i<=dx; ++i) 
03B7:  MOVF   3C,F
03B8:  BTFSS  03.2
03B9:  GOTO   3BE
03BA:  MOVF   43,W
03BB:  SUBWF  3B,W
03BC:  BTFSS  03.0
03BD:  GOTO   3DF
....................       { 
....................          glcd_pixel(x1, y1, color); 
03BE:  MOVF   34,W
03BF:  MOVWF  44
03C0:  MOVF   35,W
03C1:  MOVWF  45
03C2:  MOVF   38,W
03C3:  MOVWF  46
03C4:  CALL   2F6
....................  
....................          if(P < 0) 
03C5:  BTFSS  40.7
03C6:  GOTO   3D1
....................          { 
....................             P  += dy; 
03C7:  MOVF   39,W
03C8:  ADDWF  3F,F
03C9:  MOVF   3A,W
03CA:  BTFSC  03.0
03CB:  INCFSZ 3A,W
03CC:  ADDWF  40,F
....................             x1 += addx; 
03CD:  MOVF   3D,W
03CE:  ADDWF  34,W
03CF:  MOVWF  34
....................          } 
....................          else 
03D0:  GOTO   3DD
....................          { 
....................             P  += diff; 
03D1:  MOVF   41,W
03D2:  ADDWF  3F,F
03D3:  MOVF   42,W
03D4:  BTFSC  03.0
03D5:  INCFSZ 42,W
03D6:  ADDWF  40,F
....................             x1 += addx; 
03D7:  MOVF   3D,W
03D8:  ADDWF  34,W
03D9:  MOVWF  34
....................             y1 += addy; 
03DA:  MOVF   3E,W
03DB:  ADDWF  35,W
03DC:  MOVWF  35
....................          } 
....................       } 
03DD:  INCF   43,F
03DE:  GOTO   3B7
....................    } 
....................    else 
03DF:  GOTO   421
....................    { 
....................       dx *= 2; 
03E0:  BCF    03.0
03E1:  RLF    3B,F
03E2:  RLF    3C,F
....................       P = dx - dy; 
03E3:  MOVF   39,W
03E4:  SUBWF  3B,W
03E5:  MOVWF  77
03E6:  MOVF   3C,W
03E7:  MOVWF  7A
03E8:  MOVF   3A,W
03E9:  BTFSS  03.0
03EA:  INCFSZ 3A,W
03EB:  SUBWF  7A,F
03EC:  MOVF   77,W
03ED:  MOVWF  3F
03EE:  MOVF   7A,W
03EF:  MOVWF  40
....................       diff = P - dy; 
03F0:  MOVF   39,W
03F1:  SUBWF  3F,W
03F2:  MOVWF  41
03F3:  MOVF   40,W
03F4:  MOVWF  42
03F5:  MOVF   3A,W
03F6:  BTFSS  03.0
03F7:  INCFSZ 3A,W
03F8:  SUBWF  42,F
....................  
....................       for(; i<=dy; ++i) 
03F9:  MOVF   3A,F
03FA:  BTFSS  03.2
03FB:  GOTO   400
03FC:  MOVF   43,W
03FD:  SUBWF  39,W
03FE:  BTFSS  03.0
03FF:  GOTO   421
....................       { 
....................          glcd_pixel(x1, y1, color); 
0400:  MOVF   34,W
0401:  MOVWF  44
0402:  MOVF   35,W
0403:  MOVWF  45
0404:  MOVF   38,W
0405:  MOVWF  46
0406:  CALL   2F6
....................  
....................          if(P < 0) 
0407:  BTFSS  40.7
0408:  GOTO   413
....................          { 
....................             P  += dx; 
0409:  MOVF   3B,W
040A:  ADDWF  3F,F
040B:  MOVF   3C,W
040C:  BTFSC  03.0
040D:  INCFSZ 3C,W
040E:  ADDWF  40,F
....................             y1 += addy; 
040F:  MOVF   3E,W
0410:  ADDWF  35,W
0411:  MOVWF  35
....................          } 
....................          else 
0412:  GOTO   41F
....................          { 
....................             P  += diff; 
0413:  MOVF   41,W
0414:  ADDWF  3F,F
0415:  MOVF   42,W
0416:  BTFSC  03.0
0417:  INCFSZ 42,W
0418:  ADDWF  40,F
....................             x1 += addx; 
0419:  MOVF   3D,W
041A:  ADDWF  34,W
041B:  MOVWF  34
....................             y1 += addy; 
041C:  MOVF   3E,W
041D:  ADDWF  35,W
041E:  MOVWF  35
....................          } 
....................       } 
041F:  INCF   43,F
0420:  GOTO   3F9
....................    } 
.................... } 
0421:  RETLW  00
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_rect(int16 x1, int16 y1, int16 x2, int16 y2, int1 fill, int1 color) 
.................... #else 
.................... void glcd_rect(int8 x1, int8 y1, int8 x2, int8 y2, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    if(fill) 
0422:  MOVF   2D,F
0423:  BTFSC  03.2
0424:  GOTO   455
....................    { 
....................       #ifdef LARGE_LCD 
....................       int16 i, xmin, xmax, ymin, ymax; 
....................       #else 
....................       int8  i, xmin, xmax, ymin, ymax; 
....................       #endif 
....................  
....................       if(x1 < x2)                            //  Find x min and max 
0425:  MOVF   2B,W
0426:  SUBWF  29,W
0427:  BTFSC  03.0
0428:  GOTO   42E
....................       { 
....................          xmin = x1; 
0429:  MOVF   29,W
042A:  MOVWF  30
....................          xmax = x2; 
042B:  MOVF   2B,W
042C:  MOVWF  31
....................       } 
....................       else 
042D:  GOTO   432
....................       { 
....................          xmin = x2; 
042E:  MOVF   2B,W
042F:  MOVWF  30
....................          xmax = x1; 
0430:  MOVF   29,W
0431:  MOVWF  31
....................       } 
....................  
....................       if(y1 < y2)                            // Find the y min and max 
0432:  MOVF   2C,W
0433:  SUBWF  2A,W
0434:  BTFSC  03.0
0435:  GOTO   43B
....................       { 
....................          ymin = y1; 
0436:  MOVF   2A,W
0437:  MOVWF  32
....................          ymax = y2; 
0438:  MOVF   2C,W
0439:  MOVWF  33
....................       } 
....................       else 
043A:  GOTO   43F
....................       { 
....................          ymin = y2; 
043B:  MOVF   2C,W
043C:  MOVWF  32
....................          ymax = y1; 
043D:  MOVF   2A,W
043E:  MOVWF  33
....................       } 
....................  
....................       for(; xmin <= xmax; ++xmin) 
043F:  MOVF   30,W
0440:  SUBWF  31,W
0441:  BTFSS  03.0
0442:  GOTO   454
....................       { 
....................          for(i=ymin; i<=ymax; ++i) 
0443:  MOVF   32,W
0444:  MOVWF  2F
0445:  MOVF   2F,W
0446:  SUBWF  33,W
0447:  BTFSS  03.0
0448:  GOTO   452
....................          { 
....................             glcd_pixel(xmin, i, color); 
0449:  MOVF   30,W
044A:  MOVWF  44
044B:  MOVF   2F,W
044C:  MOVWF  45
044D:  MOVF   2E,W
044E:  MOVWF  46
044F:  CALL   2F6
....................          } 
0450:  INCF   2F,F
0451:  GOTO   445
....................       } 
0452:  INCF   30,F
0453:  GOTO   43F
....................    } 
....................    else 
0454:  GOTO   481
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
0455:  MOVF   29,W
0456:  MOVWF  34
0457:  MOVF   2A,W
0458:  MOVWF  35
0459:  MOVF   2B,W
045A:  MOVWF  36
045B:  MOVF   2A,W
045C:  MOVWF  37
045D:  MOVF   2E,W
045E:  MOVWF  38
045F:  CALL   36C
....................       glcd_line(x1, y2, x2, y2, color); 
0460:  MOVF   29,W
0461:  MOVWF  34
0462:  MOVF   2C,W
0463:  MOVWF  35
0464:  MOVF   2B,W
0465:  MOVWF  36
0466:  MOVF   2C,W
0467:  MOVWF  37
0468:  MOVF   2E,W
0469:  MOVWF  38
046A:  CALL   36C
....................       glcd_line(x1, y1, x1, y2, color); 
046B:  MOVF   29,W
046C:  MOVWF  34
046D:  MOVF   2A,W
046E:  MOVWF  35
046F:  MOVF   29,W
0470:  MOVWF  36
0471:  MOVF   2C,W
0472:  MOVWF  37
0473:  MOVF   2E,W
0474:  MOVWF  38
0475:  CALL   36C
....................       glcd_line(x2, y1, x2, y2, color); 
0476:  MOVF   2B,W
0477:  MOVWF  34
0478:  MOVF   2A,W
0479:  MOVWF  35
047A:  MOVF   2B,W
047B:  MOVWF  36
047C:  MOVF   2C,W
047D:  MOVWF  37
047E:  MOVF   2E,W
047F:  MOVWF  38
0480:  CALL   36C
....................    } 
.................... } 
0481:  BCF    0A.3
0482:  BCF    0A.4
0483:  GOTO   599 (RETURN)
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_bar(int16 x1, int16 y1, int16 x2, int16 y2, int8 width, int1 color) 
.................... #else 
.................... void glcd_bar(int8 x1, int8 y1, int8 x2, int8 y2, int8 width, int1 color) 
.................... #endif 
.................... { 
....................    int8         half_width; 
....................    signed int16 dy, dx; 
....................    signed int8  addx=1, addy=1, j; 
....................    signed int16 P, diff, c1, c2; 
....................  
....................    #ifdef LARGE_LCD 
....................    int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
....................    dy = abs((signed int8)(y2 - y1)); 
....................    #endif 
....................  
....................    half_width = width/2; 
....................    c1 = -(dx*x1 + dy*y1); 
....................    c2 = -(dx*x2 + dy*y2); 
....................  
....................    if(x1 > x2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addx = -1; 
....................    } 
....................    if(y1 > y2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addy = -1; 
....................    } 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................       diff = P - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................             #ifdef LARGE_LCD 
....................             int16 temp; 
....................             #else 
....................             int8 temp; 
....................             #endif 
....................  
....................             temp = dx*x1+dy*(y1+j);    // Use more RAM to increase speed 
....................             if(temp+c1 >= 0 && temp+c2 <=0) 
....................                glcd_pixel(x1, y1+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dy; 
....................             x1 += addx; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................       diff = P - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dx; 
....................             y1 += addy; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................             #ifdef LARGE_LCD 
....................             int16 temp; 
....................             #else 
....................             int8 temp; 
....................             #endif 
....................  
....................             temp = dx*x1+dy*(y1+j);    // Use more RAM to increase speed 
....................             if(temp+c1 >= 0 && temp+c2 <=0) 
....................                glcd_pixel(x1+j, y1, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_circle(int16 x, int16 y, int16 radius, int1 fill, int1 color) 
.................... #else 
.................... void glcd_circle(int8 x, int8 y, int8 radius, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    #ifdef LARGE_LCD 
....................    signed int16 a, b, P; 
....................    #else 
....................    signed int8  a, b, P; 
....................    #endif 
....................  
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P += 3 + 2 * a++; 
....................       else 
....................          P += 5 + 2 * (a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_text57(int16 x, int16 y, char* textptr, int8 size, int1 color) 
.................... #else 
.................... void glcd_text57(int8 x, int8 y, char* textptr, int8 size, int1 color) 
.................... #endif 
.................... { 
....................    int8 j, k, l, m;                       // Loop counters 
....................    int8 pixelData[5];                     // Stores character data 
....................  
....................    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string 
0484:  MOVF   2C,W
0485:  MOVWF  7A
0486:  MOVF   2B,W
0487:  MOVWF  04
0488:  BCF    03.7
0489:  BTFSC  7A.0
048A:  BSF    03.7
048B:  MOVF   00,F
048C:  BTFSC  03.2
048D:  GOTO   559
....................    { 
....................       if(*textptr < 'S') // Checks if the letter is in the first font array 
048E:  MOVF   2C,W
048F:  MOVWF  7A
0490:  MOVF   2B,W
0491:  MOVWF  04
0492:  BCF    03.7
0493:  BTFSC  7A.0
0494:  BSF    03.7
0495:  MOVF   00,W
0496:  SUBLW  52
0497:  BTFSS  03.0
0498:  GOTO   4B7
....................          memcpy(pixelData, FONT[*textptr - ' '], 5); 
0499:  MOVF   2C,W
049A:  MOVWF  7A
049B:  MOVF   2B,W
049C:  MOVWF  04
049D:  BCF    03.7
049E:  BTFSC  7A.0
049F:  BSF    03.7
04A0:  MOVLW  20
04A1:  SUBWF  00,W
04A2:  MOVWF  3A
04A3:  MOVWF  3B
04A4:  MOVLW  05
04A5:  MOVWF  3C
04A6:  CALL   214
04A7:  MOVF   78,W
04A8:  MOVWF  3B
04A9:  MOVWF  79
04AA:  MOVLW  05
04AB:  MOVWF  78
04AC:  MOVLW  33
04AD:  MOVWF  04
04AE:  BCF    03.7
04AF:  MOVF   79,W
04B0:  CALL   004
04B1:  MOVWF  00
04B2:  INCF   79,F
04B3:  INCF   04,F
04B4:  DECFSZ 78,F
04B5:  GOTO   4AF
....................       else if(*textptr <= '~') // Check if the letter is in the second font array 
04B6:  GOTO   4E5
04B7:  MOVF   2C,W
04B8:  MOVWF  7A
04B9:  MOVF   2B,W
04BA:  MOVWF  04
04BB:  BCF    03.7
04BC:  BTFSC  7A.0
04BD:  BSF    03.7
04BE:  MOVF   00,W
04BF:  SUBLW  7E
04C0:  BTFSS  03.0
04C1:  GOTO   4E0
....................          memcpy(pixelData, FONT2[*textptr - 'S'], 5); 
04C2:  MOVF   2C,W
04C3:  MOVWF  7A
04C4:  MOVF   2B,W
04C5:  MOVWF  04
04C6:  BCF    03.7
04C7:  BTFSC  7A.0
04C8:  BSF    03.7
04C9:  MOVLW  53
04CA:  SUBWF  00,W
04CB:  MOVWF  3A
04CC:  MOVWF  3B
04CD:  MOVLW  05
04CE:  MOVWF  3C
04CF:  CALL   214
04D0:  MOVF   78,W
04D1:  MOVWF  3B
04D2:  MOVWF  79
04D3:  MOVLW  05
04D4:  MOVWF  78
04D5:  MOVLW  33
04D6:  MOVWF  04
04D7:  BCF    03.7
04D8:  MOVF   79,W
04D9:  CALL   10A
04DA:  MOVWF  00
04DB:  INCF   79,F
04DC:  INCF   04,F
04DD:  DECFSZ 78,F
04DE:  GOTO   4D8
....................       else 
04DF:  GOTO   4E5
....................          memcpy(pixelData, FONT[0], 5);   // Default to space 
04E0:  CLRF   33
04E1:  CLRF   34
04E2:  CLRF   35
04E3:  CLRF   36
04E4:  CLRF   37
....................  
....................       // Handles newline and carriage returns 
....................       switch(*textptr) 
....................       { 
04E5:  MOVF   2C,W
04E6:  MOVWF  7A
04E7:  MOVF   2B,W
04E8:  MOVWF  04
04E9:  BCF    03.7
04EA:  BTFSC  7A.0
04EB:  BSF    03.7
04EC:  MOVF   00,W
04ED:  XORLW  0A
04EE:  BTFSC  03.2
04EF:  GOTO   4F4
04F0:  XORLW  07
04F1:  BTFSC  03.2
04F2:  GOTO   4FD
04F3:  GOTO   4FF
....................          case '\n': 
....................             y += 7*size + 1; 
04F4:  MOVLW  07
04F5:  MOVWF  3B
04F6:  MOVF   2D,W
04F7:  MOVWF  3C
04F8:  CALL   214
04F9:  MOVLW  01
04FA:  ADDWF  78,W
04FB:  ADDWF  2A,F
....................             continue; 
04FC:  GOTO   554
....................          case '\r': 
....................             x = 0; 
04FD:  CLRF   29
....................             continue; 
04FE:  GOTO   554
....................       } 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
04FF:  MOVLW  05
0500:  MOVWF  3B
0501:  MOVF   2D,W
0502:  MOVWF  3C
0503:  CALL   214
0504:  MOVF   78,W
0505:  ADDWF  29,W
0506:  SUBLW  7F
0507:  BTFSC  03.0
0508:  GOTO   512
....................       { 
....................          x = 0;                           // Set x at far left position 
0509:  CLRF   29
....................          y += 7*size + 1;                 // Set y at next position down 
050A:  MOVLW  07
050B:  MOVWF  3B
050C:  MOVF   2D,W
050D:  MOVWF  3C
050E:  CALL   214
050F:  MOVLW  01
0510:  ADDWF  78,W
0511:  ADDWF  2A,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
0512:  CLRF   2F
0513:  MOVF   2F,W
0514:  SUBLW  04
0515:  BTFSS  03.0
0516:  GOTO   554
....................       { 
....................          for(k=0; k < 7; ++k)             // Loop through the vertical pixels 
0517:  CLRF   30
0518:  MOVF   30,W
0519:  SUBLW  06
051A:  BTFSS  03.0
051B:  GOTO   550
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
051C:  MOVLW  33
051D:  ADDWF  2F,W
051E:  MOVWF  04
051F:  BCF    03.7
0520:  MOVF   00,W
0521:  MOVWF  38
0522:  MOVWF  77
0523:  MOVF   30,W
0524:  MOVWF  78
0525:  BTFSC  03.2
0526:  GOTO   52B
0527:  BCF    03.0
0528:  RRF    77,F
0529:  DECFSZ 78,F
052A:  GOTO   527
052B:  BTFSS  77.0
052C:  GOTO   54E
....................             { 
....................                for(l=0; l < size; ++l)    // These two loops change the 
052D:  CLRF   31
052E:  MOVF   2D,W
052F:  SUBWF  31,W
0530:  BTFSC  03.0
0531:  GOTO   54E
....................                {                          // character's size 
....................                   for(m=0; m < size; ++m) 
0532:  CLRF   32
0533:  MOVF   2D,W
0534:  SUBWF  32,W
0535:  BTFSC  03.0
0536:  GOTO   54C
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
0537:  MOVF   32,W
0538:  ADDWF  29,W
0539:  MOVWF  38
053A:  MOVF   30,W
053B:  MOVWF  3B
053C:  MOVF   2D,W
053D:  MOVWF  3C
053E:  CALL   214
053F:  MOVF   78,W
0540:  ADDWF  2A,W
0541:  ADDWF  31,W
0542:  MOVWF  3A
0543:  MOVF   38,W
0544:  MOVWF  44
0545:  MOVF   3A,W
0546:  MOVWF  45
0547:  MOVF   2E,W
0548:  MOVWF  46
0549:  CALL   2F6
....................                   } 
054A:  INCF   32,F
054B:  GOTO   533
....................                } 
054C:  INCF   31,F
054D:  GOTO   52E
....................             } 
....................          } 
054E:  INCF   30,F
054F:  GOTO   518
....................       } 
0550:  INCF   2F,F
0551:  MOVF   2D,W
0552:  ADDWF  29,F
0553:  GOTO   513
....................    } 
0554:  INCF   2B,F
0555:  BTFSC  03.2
0556:  INCF   2C,F
0557:  INCF   29,F
0558:  GOTO   484
.................... } 
0559:  BCF    0A.3
055A:  BCF    0A.4
055B:  GOTO   5A4 (RETURN)
....................  
.................... #endif 
....................  
....................  
.................... void main(){                
055C:  CLRF   04
055D:  BCF    03.7
055E:  MOVLW  1F
055F:  ANDWF  03,F
0560:  BSF    03.5
0561:  BSF    1F.0
0562:  BSF    1F.1
0563:  BSF    1F.2
0564:  BCF    1F.3
0565:  MOVLW  07
0566:  MOVWF  1C
....................     
....................    int data[]="LaboTEC"; 
*
056A:  MOVLW  4C
056B:  MOVWF  21
056C:  MOVLW  61
056D:  MOVWF  22
056E:  MOVLW  62
056F:  MOVWF  23
0570:  MOVLW  6F
0571:  MOVWF  24
0572:  MOVLW  54
0573:  MOVWF  25
0574:  MOVLW  45
0575:  MOVWF  26
0576:  MOVLW  43
0577:  MOVWF  27
0578:  CLRF   28
....................    glcd_init(ON);           
0579:  MOVLW  01
057A:  MOVWF  29
057B:  GOTO   239
....................  
....................    glcd_line(10,10,50,50,ON);          // GRAFICA PRIMERA DIAGONAL 
057C:  MOVLW  0A
057D:  MOVWF  34
057E:  MOVWF  35
057F:  MOVLW  32
0580:  MOVWF  36
0581:  MOVWF  37
0582:  MOVLW  01
0583:  MOVWF  38
0584:  CALL   36C
....................    glcd_line(50,10,10,50,ON);          // GRAFICO SEGUNDA DIAGONAL 
0585:  MOVLW  32
0586:  MOVWF  34
0587:  MOVLW  0A
0588:  MOVWF  35
0589:  MOVWF  36
058A:  MOVLW  32
058B:  MOVWF  37
058C:  MOVLW  01
058D:  MOVWF  38
058E:  CALL   36C
....................    glcd_rect(10,10,50,50,0,ON);        // DIBUJO UN RECTANGULO     
058F:  MOVLW  0A
0590:  MOVWF  29
0591:  MOVWF  2A
0592:  MOVLW  32
0593:  MOVWF  2B
0594:  MOVWF  2C
0595:  CLRF   2D
0596:  MOVLW  01
0597:  MOVWF  2E
0598:  GOTO   422
....................    glcd_text57(60,10,data,1,ON);       // ENVIO UN TEXTO 
0599:  MOVLW  3C
059A:  MOVWF  29
059B:  MOVLW  0A
059C:  MOVWF  2A
059D:  CLRF   2C
059E:  MOVLW  21
059F:  MOVWF  2B
05A0:  MOVLW  01
05A1:  MOVWF  2D
05A2:  MOVWF  2E
05A3:  GOTO   484
....................     
....................    for(;;){ 
....................    } 
05A4:  GOTO   5A4
.................... } 
....................  
....................  
....................  
05A5:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
